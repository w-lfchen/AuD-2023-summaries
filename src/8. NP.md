---
tags: aud
---
# 8. NP
## Ansatz
Problem ist leicht, wenn es in Polynomialzeit l√∂sbar ist.
Worst-Case-Laufzeit des Algorithmus ist also $\Theta\left(\sum\limits_{i=0}^k a_i n^i\right)= poly(n)$ mit konstanten $a_i, k$
Leicht zu l√∂sende Problem:
- Sortieren eines Arrays
- Breitensuche im Graphen
- Minimale Spannb√§ume berechnen
- ...
Probleme mit leicht zu √ºberpr√ºfender L√∂sung:
- TSP
- Faktorisieren
- ...
Unentscheidbare Probleme:
- Halteproblem
- Code-Erreichbarkeit
- ...
# Berechnungsprobleme vs. Entscheidungsprobleme
Berechnungsproblem:
- Gegeben: Problem $P$
- Gesucht: L√∂sung $S$
- Beispiel: Berechne k√ºrzeste Pfade im Graphen
Entscheidungsproblem:
- Gegeben: Problem $P$
- Gesucht: Hat $P$ Eigenschaft $E$? Antwort ist wahr/falsch
- Beispiel: Ist gerichteter Graph stark zusammenh√§ngend?
Im Folgenden werden nur Entscheidungsprobleme betrachtet
Man kann jedes Berechnungs- in ein Entscheidungsproblem √ºberf√ºhren, so dass Polynomialzeit-L√∂sung f√ºr Entscheidungsproblem auch Polynomialzeit-L√∂sung f√ºr Berechnungsproblem ergibt.
## Beispiel: Faktorisieren
Faktorisierungsproblem (Berechnungsproblem):
- Gegeben: $n$-Bit Zahl $N \ge 2$
- Gesucht: Primfaktoren von $N$
$\Rightarrow$ Entscheidungsproblem:
- Gegeben: $n$-Bit Zahl $N \ge 2$, zahl $B$
- Gesucht: Ist kleinster Primfaktor von $N$ maximal $B$?
```
Factorize(N) // N>1
	WHILE N>1 DO
		p=computeFactor(N);
		print p;
		N=N/p;

computeFactor(N) // use decideFactor(N,B) as sub, N>1, computes prime factor of N
	L=1; U=N;
	WHILE L!=U DO
		M=L+floor((U-L)/2);
		IF decideFactor(N,M)==1 THEN U=M ELSE L=M+1;
	return L;

decideFactor(N,B)
	...
	return d; // d==0 or d==1
```
- `sub` steht f√ºr Suboutine
In jeder Iteration wird Suchintervall um H√§lfte reduziert, runden kann man ignorieren
Zu Beginn Intervalll√§nge $N$, also nach $\Theta(\log_2 N) = \Theta(n)$ Iterationen fertig
Laufzeit $\Theta(\log_2 N) = \Theta(n)$ Iterationen von `decideFactor`, in jeder Iteration konstanter Aufwand
Laufzeit `Factorize`:
In jeder Iteration wird Primfaktor $p \ge 2$ abgespalten, also maximal $\Theta(\log_2 N) = \Theta(n)$ Iterationen
Annahme der Laufzeit von  `decideFactor`: $poly(n)$
Gesamtlaufzeit $\Theta(n^2 \cdot poly(n))$
## Berechnung durch Entscheidung
Berechnungsproblem:
- Gegeben: Problem $P$
- Gesucht: L√∂sung $S$
Kreiere daraus Entscheidungsproblem:
- Gegeben: Problem $P$, String $s$
- Gesucht: Ist $s$ Pr√§fix der Bin√§rdarstellung einer L√∂sung $S$?
```
compute(P) // use decide(P,s) as sub
	s=""; // empty string
	IF decide(P,s)==0 THEN return "no solution";
	done=false;
	WHILE !done DO
		szero=decide(P,s+"0");
		sone =decide(P,s+"1");
		IF szero==0 AND sone==0 THEN // solution found
			done=true
		ELSE IF szero==1 THEN s=s+"0" ELSE s=s+"1";
	return "solution " + s;

decide(P,s)
	...
	return d; // d==0/d==1
```
Sofern Bitl√§nge der L√∂sungen polynomiell beschr√§nkt ist und `decide` in Polynomialzeit l√§uft, l√§uft `compute` auch in Polynomialzeit
Es wird bit-weise in richtige Richtung gesucht
Laufzeit: $\Theta \left(2 \cdot \max\limits_S |S| +1\right)$ Iterationen von `decide`
# Komplexit√§tsklassen P und NP
## Komplexit√§tsklasse P
Betrachte Entscheidungsproblem f√ºr Eigenschaft als Menge: $L_E := \{P : P \text{ hat  Eigenschat } E\}$
$L$ kommt von "language"
Beispiel: $L_{Sc} := \{G : G \text{ ist gerichtetet, stark zusammenh√§ngender Graph}\}$
Komplexit√§tsklasse P:
Ein Entscheidungsproblem $L_E$ ist genau dann in der Komplexit√§tsklasse P, wenn es einen Polynomialzeit-Algorithmus $A_{L_E}$ mit Ausgabe 0/1 gibt, der stets korrekt entscheidet, ob eine Eingabe $P$ die Eigenschaft $E$ hat oder nicht, also $P \in L_E \Leftrightarrow A_{L_E}(P)=1$ f√ºr alle $P$ gilt.
Eigentliche Definition: Algorithmus = Turing-Maschine und Problem-Universum = $\{0,1\}^*$
## Komplexit√§tsklasse NP
Das Pr√ºfen einer vermeintlichen L√∂sung ist einfach f√ºr $L_E$:
- Gegeben: Problem $P$ und vermeintliche L√∂sung $S$
- Entscheide: Zeigt $S$, dass $P$ Eigenschaft $E$ hat oder nicht?
- $S$ dient als zus√§tzliche Entscheidungshilfe, hei√üt auch "witness", Zeuge, Zertifikat,... f√ºr $P$
Technische Einschr√§nkung:
L√∂sungen $S$ sind von polynomieller Komplexit√§t in Eingabeproblem $P$, meist: L√∂sungen  $S$ haben polynomielle Bitl√§nge (in Bitl√§nge von $P$)
### Beispiel
$L_{Fakt} := \{(N,B) : V > \text{ hat Primfaktor } \le B\}$
Gegenw√§rtig ist es unklar, wie in Polynomialzeit ohne Hilfe (und ohne Quantencomputer) entschieden werden kann, ob Eingabe $(N,B)$ in $L_{Fakt}$ ist oder nicht
Mit Hilfe ist das Entscheiden einfach:
Zeuge $S$ zu $P = (N,B)$ ist Faktor $p$ von $N$ mit $1 < p \le B$
```
verify(N,B,p) // check alleged solution
1 IF N>1 AND 1<p=<B AND p|N THEN return 1 else return 0;
```
Es wird nicht gepr√ºft, ob $p$ prim ist, wenn der zusammengesetzte Faktor in der Schranke $B$ liegt, dann ist $p$ erst recht ein Primfaktor
Es gibt keine falshce Hilfe f√ºr nicht-zugeh√∂rige Eingaben:
- Wenn $(N,B) \in L_{Fakt}$, dann gibt es ein $S$, das `verify` akzeptieren l√§sst
- Wenn $(N,B) \notin L_{Fakt}$, dann gibt es kein $S$, das `verify` akzeptieren l√§sst
Entscheidung mit Hilfe muss in beiden F√§llen richtig sein
### NP (Nicht-deterministische Polynomialzeit)
Ein Entscheidungsproblem $L_E$ ist in der Komplexit√§tsklasse NP gdw. es einen Polynomialzeit-Algorithmus $A_{L_E}$ mit Ausgabe 0/1 gibt, der bei Eingabe eines Zeugen $S_P$ f√ºr Eingabe $P \in L_E$ bzw. f√ºr jede Eingabe $S_P$ f√ºr Eingabe $P \notin L_E$ stets korrekt entscheidet, ob eine Eingabe $P$ die Eigenschaft $E$ hat oder nicht, also $P \in L_E \Leftrightarrow \exists S_P : A_{L_E}(P,S_P) =1$ f.a. $P$ gilt.
√Ñquivalent: F.a. $P$ gilt $P \notin L_E \Leftrightarrow \forall S_P : A_{L_E}(P,S_P) =0$
Komplexit√§t der Hilfseingabe $S_P$ polynomiell in der von $P$
## P vs. NP
Jedes Problem in P ist auch in NP: Algorithmus $A_{L_E}$ entscheidet ohne Hilfe $\leadsto$ P $\subseteq$ NP
Bis heute ist offen, ob auch NP $\subseteq$ P gilt
### M√∂gliche Welten
[[#Beispiel Faktorisieren|Faktorisieren]] ist in NP, jedoch ist nicht klar, ob Faktorisieren auch in P liegt.
1. Wahrscheinlichste Welt, Bild wird durch Quantum-Computer verfeinert:
   P $\ne$ NP, Faktorisieren $\notin$ P $\leadsto$ Faktorisieren schwierig
2. P $\ne$ NP, Faktorisieren $\in$ P $\leadsto$ Faktorisieren leicht
3. P = NP $\leadsto$ Alle Probleme sind leicht
# NP-Vollst√§ndigkeit
## Ziel: Identifiziere schwierigsten Probleme in NP
NPC (NP-Complete): Klasse der NP-vollst√§ndigen Probleme
Eigenschaften:
1. NPC $\subseteq$ NP
2. Wenn P $\ne$ NP, dann definitiv NPC $\nsubseteq$ P
## Reduktionen (Problemtransformationen)
Siehe [[#Berechnung durch Entscheidung]] f√ºr Problemdefinition
Wenn das Entscheidungsproblem leicht ist, ist das Berechnungsproblem es auch
Das Entscheidungsproblem ist mindestens so schwierig wie das Berechnungsproblem
### Transfer auf NP-Entscheidungsprobleme
NP-Problem $L_A$:
- Gegeben: Problem $P$
- Gesucht: Entscheidung
Reduktion auf NP-Problem $L_B$:
- Gegeben: Problem $Q$
- Gesucht: Entscheidung
Die Reduktion von $L_A$ auf $L_B$ ist Polynomialzeit-Algorithmus $R$, sodass gilt: 
$P \in L_A \Leftrightarrow R(P) \in L_B$ f.a. $P$, Schreibweise: $L_A \le L_B$
Die Reduktion transformiert Problem $P$ in Problem $Q = R(P)$, sodass eine korrekte Entscheidung f√ºr $Q$ automatisch eine korrekte Entscheidung f√ºr $P$ liefert
```
decideA(P)
	Q=R(P);
	return decideB(Q);

decideB(Q)
	...
	return d; // boolean
```
## NP-vollst√§ndige Probleme
Komplexit√§tsklasse NPC (NP-vollst√§ndige Probleme):
Alle Probleme $L_C \in$ NP, sodass $L_A \le L_C$ f.a. $L_A \in$ NP
Zwei Bedingungen an $L_C$:
1. $L_C \in$ NP
2. jedes NP-Problem ist auf $L_C$ reduzierbar ($L_C$ ist NP-hart)
## Beispiel f√ºr Reduktion: Hamiltonscher Zyklus $\le$ TSP
- HamCycle f√ºr $G$:
  Gibt es Tour (jeden Knoten einmal besuchen und zu Startknoten zur√ºck) im Graphen $G$?
- TSP f√ºr $(G,B)$:
  Gibt es Tour im Graphen $G$ mit Gewicht maximal $B$?
  Beide Probleme sind in NP
  Reduktion:
  Existierende Kanten bekommen Gewicht 0, vervollst√§ndige anschlie√üend Graphen mit Kanten mit Gewicht 1, setze $B=0$
  Nun zu zeigen: $G \in$ HamCycle $\Leftrightarrow$ $R(G) = (G^*, B) \in$ TSP
## SAT: Die Mutter aller NP-vollst√§ndigen Probleme
Gegeben:
Boolesche Formel $\phi$ aus $\vee, \wedge, \neg$ in $n$ variablen $x_1, x_2, \dots, x_n$
$\phi$ hat polynomielle Komplexit√§t in $n$
Gesucht:
Entscheide, ob $\phi$ erf√ºllende Belegung hat oder nicht
SAT $\in$ NP: Gegeben ist Belegung als Zeuge, werte Formel aus
### SAT ist NP-hart
Zu zeigen:
Jedes Problem $L_A \in NP$ l√§sst sich auf SAT reduzieren (Definition der H√§rte)
Sei nun also $L_A \in NP$ ein beliebiges Problem, dann hat es einen $poly$-Algorithmus `verifyA(P,S)`.
- Man kann alles als Bits betrachten, die eine (sehr lange) boolesche Formel darstellen k√∂nnen
- Kodiere nun folgende Teile von `verifyA` als boolsche Formel:
  - Legitime Anfangszust√§nde
  - Legitime Endzust√§nde
  - Legitime Rechenschritte
- Polynomiell, da `verifyA` polynomiell ist
Reduktion $R(P)$ von $L_A$ auf SAT berechnet dann:
$\phi_P(\text{alle Eingabebits})$ = g√ºltiger Anfangszustand f√ºr $P \wedge$ g√ºltige √úberg√§nge $\wedge$ Endzustand mit Ausgabe $d=1$
Wenn P in $L_A$ ist, gibt es eine L√∂sung $S$, die `verifyA` mit $d=1$ akzeptiert, dann gibt es aber auch eine erf√ºllende Belegung f√ºr "Rechenschritte" $\phi_P$
Wenn P  nicht in $L_A$ ist, gibt es keine L√∂sung $S$, die `verifyA` akzeptiert, dann gibt es aber auch keine erf√ºllende Belegung f√ºr "Rechenschritte" $\phi_P$
## SAT $\le$ 3SAT
Boolesche Formeln in konjunktiver Normalform (KNF) mit jeweils 3 Literalen:
$\phi(x_1, x_2, x_3, x_4) = (\neg x_2 \wedge x_3 \wedge x_4) \vee (x_1 \wedge \neg x_2 \wedge x_3) \vee (x_4 \wedge x_3 \wedge x_4)$
KNF = Und-Verkn√º√ºfung von Klauseln, Klausel = Oder-Verkn√ºpfung
Klausel besteht aus 3 Literalen $x_j \in \{x_j, \neg x_j\}$
Falls weniger Literale in Klausel, transformiere: $(x_j) = (x_j \wedge x_j \wedge x_j), (x_j \wedge x_k) = (x_j \wedge x_k \wedge x_k)$
3SAT:
Gegeben:
Boolesche 3KNF-Formel $\phi$ in $n$ Variablen $x_1, x_2, \dots, x_n$, $\phi$ hat polynomielle Komplexit√§t in $n$
Gesucht:
Entscheide, ob $\phi$ erf√ºllende Belegung hat oder nicht
SAT: Boolesche Formel $\sigma$ aus $\vee, \wedge, \neg$ in $n$ Variablen $y_1, y_2, \dots, y_n$ ($\sigma$ polynomielle Komplexit√§t in $n$)
l√§sst sich in Polynomialzeit √ºberf√ºhren zu
3SAT: 3KNF-Formel $\phi$ in $poly(n)$ Variablen $x_1, x_2, \dots, x_{poly(n)}$ ($\phi$ polynomielle Komplexit√§t in $n$)
sodass $\sigma$ erf√ºllbar ist gdw. $\phi$ erf√ºllbar ist $\leadsto$ SAT $\le$ 3SAT
## 3-F√§rbbarkeit von Graphen
3COLORING f√ºr $G$:
Gibt es eine Knotenf√§rbung im Graphen $G$ mit 3 Farben, sodass benachbarte Knoten nie die gleiche Farbe haben?
3COLORING $\in$ NP:
Gegeben F√§rbung, durchlaufe Knoten und pr√ºfe jeweils Farbe der Nachbarknoten
### 3SAT $\le$ 3COLORING
![[8 3COLORING 1.png]]
- Bilde Graphen dieser Struktur f√ºr alle Klauseln in gegebener 3SAT-Formel $\phi$
- Der Farben/Belegung-Teil legt die Farben fest, da jeder dieser 3 Knoten eine andere Farbe haben muss
- F√ºr jede Variable in $\phi$ bilde zwei Knoten mit beiden Literalen, verbinde diese
  - Verbinde alle Literalknoten mit der als N (neutral) festgelegten Farbe
  - Somit m√ºssen alle Literale $true$ oder $false$ sein, und die Negierung ist auch erf√ºllt
- Lege nun mit 2 Kanten zu den Farben f√ºr jede Klausel einen Knoten als $true$ fest
- Schlie√üe nun alle Literale entsprechend den Klauseln an jeden Klauselgraph an
- Wenn der resultierende Graph 3-f√§rbbar ist, so ist $\phi$ erf√ºllbar
## Einer f√ºr alle, alle f√ºr einen
Wenn Problem $L_B$ NP-vollst√§ndig ist und $L_B \le l_C$ f√ºr $L_C \in$ NP gilt, dann ist auch $L_C$ NP-vollst√§ndig.
$L_A \le L_B$ per Reduktion $R_{AB}$, $L_B \le L_C$ per Reduktion $R_{BC}$ $\leadsto L_A \le L_C$ per Reduktion $R_{AC} := R_{BC} \circ R_{AB}$ (Hintereinanderausf√ºhrung)
Also folgt aus 3SAT $\le$ 3COLORING und 3COLORING $\in$ NP auch, dass 3COLORING NP-vollst√§ndig ist.
## NPC ‚Äì eine Auswahl
- SAT: Ist Formel $\phi$ erf√ºllbar?
- 3SAT: Ist Formel $\phi$ in 3KNF erf√ºllbar?
- 3COLORING: Ist Graph mit 3 Farben kantenkonsistent f√§rbbar?
- HamCycle: Gibt es eine Tour im Graphen?
- TSP: Gibt es eine Tour im Graphen, mit Gesamtgewicht $\le B$?
- VertexCover: Gibt es im Graphen eine Knotenmenge der Gr√∂√üe $\le B$, sodass jede Kante an einem der Knoten h√§ngt?
- IndependentSet: Gibt es im Graphen Knotenmenge der Gr√∂√üe $\ge B$, sodass kein Knotenpaar durch eine Kante verbunden ist?
- Knapsack: F√ºr Gegenst√§nde mit Wert und Volumen, gibt es eine Auswahl mit Gesamtwert $\ge W$, aber Gesamtvolumen $\le V$?
- ...
## P vs. NP vs. NPC
F√ºr jedes NP-vollst√§ndige Problem $L_C$ gilt: $L_C \in$ P $\Leftrightarrow$ P=NP.
Wenn es also einen Polynomialzeit-Algorithmus f√ºr ein $L_C \in$ NPC gibt, dann gibt es einen Polynomialzeit-Algorithmus f√ºr jedes Problem in NP.
## Approximation
NPC-Probleme sind vermutlich nicht effizient l√∂sbar, aber eventuell leicht approximierbar
```
3SAT-Approx(ùùì, ùíè)
	A[]=ALLOC(n); // assigment for variables
	FOR i=1 TO n DO
		A[i]=true resp. A[i]= false with probability 1/2
	return A;
```
- Algorithmus erf√ºllt im Erwartungswert mindestens die H√§lfte aller Klauseln
# 2-F√§rbbarkeit und 2SAT in P
## 2-F√§rbbarkeit von Graphen ist relativ einfach
Idee:
- Farbe eines Knoten bestimmt eindeutig Farben der Nachbarknoten
- Pr√ºfe jeweils, ob F√§rbung Widerspruch erzeugt
Ansatz:
- Beginne mit einem Knoten und beliebiger Farbe
- Durchlaufe den Graphen per BFS, f√§rbe Knoten und identifiziere eventuelle Widerspr√ºche
```
2ColoringSub(G,s,col) // G=(V,E), s node
	s.color=col; newQueue(Q); enqueue(Q,s);
	WHILE !isEmpty(Q) DO
	u=dequeue(Q);
	IF u.color==BLACK THEN nextcol=RED // change colour
	ELSE nextcol=BLACK;
	FOREACH v in adj(G,u) DO
		IF v.color==u.color THEN return 0; // check for contradiction
		If v.color==WHITE THEN // only accept nodes without colour
			v.color=nextcol;
			enqueue(Q,v);
	return 1; // no contradiction
```
Zun√§chst nur f√ºr zusammenh√§ngenden Graphen mit vorgegebenem Startknoten und vorgegebener Startfarbe
Man muss eventuell mit anderem Startknoten nochmal starten, wie ist die Farbe zu w√§hlen?
### Von gerichtet zu ungerichtet
Betrachte ungerichteten Graphen, L√∂sungsmenge √§ndert sich nicht
Bei Neustart keine Kante zwischen Zusammenhangskomponenten:
Jede individuelle 2-F√§rbung der Zusammenhangskomponenten kann zu 2-F√§rbung des Graphen kombiniert werden
```
2Coloring(G) // G=(V,E) undirected graph
	FOREACH u in V Do u.color=WHITE;
	FOREACH u in V DO
		IF u.color==WHITE THEN
			IF 2ColoringSub(G,u,BLACK)==0 THEN return 0;
	return 1;
```
Algorithmus findet ohne zus√§tzlichen Aufwand auch F√§rbung
Laufzeit $\Theta(|V| + |E|)$
## 2-SAT
Keine Symmetrie zwischen Belegungen und Farben bei 2-F√§rbbarkeit
### Implikationsgraph aus 2-SAT
Konstruiere aus Formel $\phi$ (gerichteten) Implikationsgraphen $G = (V,E)$:
1. Knotenmenge $V$ besteht aus Literalen $x_1, \neg x_1, x_2, \neg x_2, \dots, x_n, \neg x_n$
2. F√ºr jede Klausel $(x_j \wedge x_k)$ nehme Kanten $(\neg x_j, x_k)$ und $(\neg x_k, x_j)$ auf
### Starke Zusammenhangskomponenten im Implikationsgraphen
Formel ist erf√ºllbar gdw. in keiner Zusammenhangskomponenten $x_j, \neg x_j$ f√ºr ein $j$ liegen
### Erf√ºllende Belegung berechnen
Annahme: kein $x_j$ und $\neg x_j$ in gleicher SCC
SCC-dag:
Graph mit Superknoten aus allen Knoten einer SCC
Es gibt eine Kante zwischen SCCs, wenn es eine Kante f√ºr zwei Knoten aus den SCCs
1. Sortiere SCC-dag topologisch
2. Erf√ºllende Belegung (wohldefiniert, da kein $x_j$ und $\neg x_j$ in gleicher SCC, wenn erf√ºllbar):
   $x_j = true$, wenn $x_j$ in SCC nach SCC mit $\neg x_j$
   $x_j = false$, wenn $\neg x_j$ in SCC nach SCC mit $x_j$
## MAX-2SAT
Gegeben: 2SAT-Formel $\phi$, Zahl $k$
Gesucht: Gibt es eine Belegung, die mindestens $k$ Klauseln erf√ºllt?
MAX-2SAT $\in$ NPC
MAX-2SAT $\in$ NP:
Gegeben ist eine Belegung als Zeuge; pr√ºfe, ob mindestens $k$ Klauseln erf√ºllt werden
### 3SAT $\le$ MAX-2SAT
Man kann eine 3SAT-Formel $\sigma(x_1, x_2, \dots, x_n)$ mit $m$ Klauseln auf ein MAX-2SAT-Problem mit Formel $\phi(x_1, \dots, x_n, w_1, \dots, w_m)$ reduzieren.
Hierf√ºr f√ºhrt man $m$ neue Variablen $w_1, \dots w_m$ ein, f√ºr jede Klausel eine.
Anschlie√üend bildet man f√ºr jede Klausel in $\sigma$ folgendes Konstrukt in $\phi$, hier f√ºr die $h$-te Klausel $(X_i, X_j, X_k)$ dargestellt:
$$\begin{align*}
\phi(x_1, \dots, x_n, w_1, \dots, w_m) = \dots &\wedge (X_i) \wedge (X_j) \wedge (X_k) \wedge (w_h) \\
&\wedge (\neg X_i \vee \neg X_j) \wedge (\neg X_i \vee \neg X_k) \wedge (\neg X_j \vee \neg X_k) \\
&\wedge (\neg X_i \vee \neg w_h) \wedge (\neg X_j \vee \neg w_h) \wedge (\neg X_k \vee \neg w_h) \wedge \dots \\
\end{align*}$$
Nun gilt f√ºr $w_h = false$: Wenn die Klausel in $\sigma$ nicht erf√ºllbar ist, dann sind maximal 6 der 10 Klauseln in $\phi$ erf√ºllbar
Wenn die Klausel in $\sigma$ erf√ºllbar ist, dann sind bei geeigneter Wahl f√ºr $w_h$ nie mehr als 7 Klauseln erf√ºllbar.
Somit lautet die Reduktion:
- Wenn $\sigma$ erf√ºllbar ist, dann sind mindestens $k=7m$ Klauseln in $\phi$ erf√ºllbar.
- Wenn $\sigma$ nicht erf√ºllbar ist, dann sind weniger als $k=7m$ Klauseln in $\phi$ erf√ºllbar.
